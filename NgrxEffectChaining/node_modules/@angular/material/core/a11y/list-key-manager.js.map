{"version":3,"file":"list-key-manager.js","sourceRoot":"","sources":["../../../../../src/lib/core/a11y/list-key-manager.ts"],"names":[],"mappings":"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","sourcesContent":["import {QueryList} from '@angular/core';\nimport {UP_ARROW, DOWN_ARROW, TAB, HOME, END} from '../core';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\n\n/**\n * This interface is for items that can be disabled. The type passed into\n * ListKeyManager must extend this interface.\n */\nexport interface CanDisable {\n  disabled?: boolean;\n}\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends CanDisable> {\n  private _activeItemIndex: number;\n  private _activeItem: T;\n  private _tabOut: Subject<any> = new Subject();\n  private _wrap: boolean = false;\n\n  constructor(private _items: QueryList<T>) {\n  }\n\n  /**\n   * Turns on wrapping mode, which ensures that the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   *\n   * @returns The ListKeyManager that the method was called on.\n   */\n  withWrap(): this {\n    this._wrap = true;\n    return this;\n  }\n\n  /**\n   * Sets the active item to the item at the index specified.\n   *\n   * @param index The index of the item to be set as active.\n   */\n  setActiveItem(index: number): void {\n    this._activeItemIndex = index;\n    this._activeItem = this._items.toArray()[index];\n  }\n\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event: KeyboardEvent): void {\n    switch (event.keyCode) {\n      case DOWN_ARROW:\n        this.setNextItemActive();\n        break;\n      case UP_ARROW:\n        this.setPreviousItemActive();\n        break;\n      case HOME:\n        this.setFirstItemActive();\n        break;\n      case END:\n        this.setLastItemActive();\n        break;\n      case TAB:\n        // Note that we shouldn't prevent the default action on tab.\n        this._tabOut.next(null);\n        return;\n      default:\n        return;\n    }\n\n    event.preventDefault();\n  }\n\n  /** Returns the index of the currently active item. */\n  get activeItemIndex(): number {\n    return this._activeItemIndex;\n  }\n\n  /** Returns the currently active item. */\n  get activeItem(): T {\n    return this._activeItem;\n  }\n\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive(): void {\n    this._setActiveItemByIndex(this._items.length - 1, -1);\n  }\n\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive(): void {\n    this._activeItemIndex === null ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive(): void {\n    this._activeItemIndex === null && this._wrap ? this.setLastItemActive()\n                                                 : this._setActiveItemByDelta(-1);\n  }\n\n  /**\n   * Allows setting of the activeItemIndex without any other effects.\n   * @param index The new activeItemIndex.\n   */\n  updateActiveItemIndex(index: number) {\n    this._activeItemIndex = index;\n  }\n\n  /**\n   * Observable that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  get tabOut(): Observable<void> {\n    return this._tabOut.asObservable();\n  }\n\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  private _setActiveItemByDelta(delta: number, items = this._items.toArray()): void {\n    this._wrap ? this._setActiveInWrapMode(delta, items)\n               : this._setActiveInDefaultMode(delta, items);\n  }\n\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  private _setActiveInWrapMode(delta: number, items: T[]): void {\n    // when active item would leave menu, wrap to beginning or end\n    this._activeItemIndex =\n      (this._activeItemIndex + delta + items.length) % items.length;\n\n    // skip all disabled menu items recursively until an enabled one is reached\n    if (items[this._activeItemIndex].disabled) {\n      this._setActiveInWrapMode(delta, items);\n    } else {\n      this.setActiveItem(this._activeItemIndex);\n    }\n  }\n\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  private _setActiveInDefaultMode(delta: number, items: T[]): void {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n  }\n\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  private _setActiveItemByIndex(index: number, fallbackDelta: number,\n                                  items = this._items.toArray()): void {\n    if (!items[index]) { return; }\n    while (items[index].disabled) {\n      index += fallbackDelta;\n      if (!items[index]) { return; }\n    }\n    this.setActiveItem(index);\n  }\n\n}\n\n"]}