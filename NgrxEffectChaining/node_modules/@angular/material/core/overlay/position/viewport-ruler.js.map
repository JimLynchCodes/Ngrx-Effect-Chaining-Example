{"version":3,"file":"viewport-ruler.js","sourceRoot":"","sources":["../../../../../../src/lib/core/overlay/position/viewport-ruler.ts"],"names":[],"mappings":";;;;;;;;;OAAO,EAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAC,MAAM,eAAe;OACrD,EAAC,gBAAgB,EAAC,MAAM,6BAA6B;AAG5D;;;GAGG;AAEH;IAKE,uBAAY,gBAAkC;QALhD,iBA6DC;QAvDG,0CAA0C;QAC1C,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAE9B,sFAAsF;QACtF,gBAAgB,CAAC,QAAQ,EAAE,CAAC,SAAS,CAAC,cAAM,OAAA,KAAI,CAAC,sBAAsB,EAAE,EAA7B,CAA6B,CAAC,CAAC;IAC7E,CAAC;IAED,mDAAmD;IACnD,uCAAe,GAAf,UAAgB,YAAiC;QAAjC,4BAAiC,GAAjC,eAAe,IAAI,CAAC,aAAa;QAC/C,oFAAoF;QACpF,mFAAmF;QACnF,2FAA2F;QAC3F,0FAA0F;QAC1F,8EAA8E;QAC9E,sEAAsE;QACtE,2FAA2F;QAC3F,oFAAoF;QACpF,2BAA2B;QAC3B,IAAM,cAAc,GAAG,IAAI,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC;QACpE,IAAM,MAAM,GAAG,MAAM,CAAC,WAAW,CAAC;QAClC,IAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC;QAEhC,MAAM,CAAC;YACL,GAAG,EAAE,cAAc,CAAC,GAAG;YACvB,IAAI,EAAE,cAAc,CAAC,IAAI;YACzB,MAAM,EAAE,cAAc,CAAC,GAAG,GAAG,MAAM;YACnC,KAAK,EAAE,cAAc,CAAC,IAAI,GAAG,KAAK;YAClC,cAAM;YACN,YAAK;SACN,CAAC;IACJ,CAAC;IAGD;;;OAGG;IACH,iDAAyB,GAAzB,UAA0B,YAAiC;QAAjC,4BAAiC,GAAjC,eAAe,IAAI,CAAC,aAAa;QACzD,2FAA2F;QAC3F,0FAA0F;QAC1F,4FAA4F;QAC5F,oFAAoF;QACpF,wFAAwF;QACxF,sCAAsC;QACtC,IAAM,GAAG,GAAG,CAAC,YAAY,CAAC,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,SAAS,IAAI,MAAM,CAAC,OAAO,IAAI,CAAC,CAAC;QAChF,IAAM,IAAI,GAAG,CAAC,YAAY,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,UAAU,IAAI,MAAM,CAAC,OAAO,IAAI,CAAC,CAAC;QAEnF,MAAM,CAAC,EAAC,QAAG,EAAE,UAAI,EAAC,CAAC;IACrB,CAAC;IAED,kEAAkE;IAClE,8CAAsB,GAAtB;QACE,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC,eAAe,CAAC,qBAAqB,EAAE,CAAC;IACxE,CAAC;IA5DH;QAAC,UAAU,EAAE;;qBAAA;IA8Db,oBAAC;AAAD,CAAC,AA7DD,IA6DC;AAED,gDAAgD,WAA0B,EAC1B,gBAAkC;IAChF,MAAM,CAAC,WAAW,IAAI,IAAI,aAAa,CAAC,gBAAgB,CAAC,CAAC;AAC5D,CAAC;AAED,OAAO,IAAM,uBAAuB,GAAG;IACrC,yFAAyF;IACzF,OAAO,EAAE,aAAa;IACtB,IAAI,EAAE,CAAC,CAAC,IAAI,QAAQ,EAAE,EAAE,IAAI,QAAQ,EAAE,EAAE,aAAa,CAAC,EAAE,gBAAgB,CAAC;IACzE,UAAU,EAAE,+BAA+B;CAC5C,CAAC","sourcesContent":["import {Injectable, Optional, SkipSelf} from '@angular/core';\nimport {ScrollDispatcher} from '../scroll/scroll-dispatcher';\n\n\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\n@Injectable()\nexport class ViewportRuler {\n\n  /** Cached document client rectangle. */\n  private _documentRect?: ClientRect;\n\n  constructor(scrollDispatcher: ScrollDispatcher) {\n    // Initially cache the document rectangle.\n    this._cacheViewportGeometry();\n\n    // Subscribe to scroll and resize events and update the document rectangle on changes.\n    scrollDispatcher.scrolled().subscribe(() => this._cacheViewportGeometry());\n  }\n\n  /** Gets a ClientRect for the viewport's bounds. */\n  getViewportRect(documentRect = this._documentRect): ClientRect {\n    // Use the document element's bounding rect rather than the window scroll properties\n    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n    // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n    // can disagree when the page is pinch-zoomed (on devices that support touch).\n    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n    // We use the documentElement instead of the body because, by default (without a css reset)\n    // browsers typically give the document body an 8px margin, which is not included in\n    // getBoundingClientRect().\n    const scrollPosition = this.getViewportScrollPosition(documentRect);\n    const height = window.innerHeight;\n    const width = window.innerWidth;\n\n    return {\n      top: scrollPosition.top,\n      left: scrollPosition.left,\n      bottom: scrollPosition.top + height,\n      right: scrollPosition.left + width,\n      height,\n      width,\n    };\n  }\n\n\n  /**\n   * Gets the (top, left) scroll position of the viewport.\n   * @param documentRect\n   */\n  getViewportScrollPosition(documentRect = this._documentRect) {\n    // The top-left-corner of the viewport is determined by the scroll position of the document\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n    // `document.documentElement` works consistently, where the `top` and `left` values will\n    // equal negative the scroll position.\n    const top = -documentRect.top || document.body.scrollTop || window.scrollY || 0;\n    const left = -documentRect.left || document.body.scrollLeft || window.scrollX || 0;\n\n    return {top, left};\n  }\n\n  /** Caches the latest client rectangle of the document element. */\n  _cacheViewportGeometry?() {\n    this._documentRect = document.documentElement.getBoundingClientRect();\n  }\n\n}\n\nexport function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler: ViewportRuler,\n                                                scrollDispatcher: ScrollDispatcher) {\n  return parentRuler || new ViewportRuler(scrollDispatcher);\n}\n\nexport const VIEWPORT_RULER_PROVIDER = {\n  // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n  provide: ViewportRuler,\n  deps: [[new Optional(), new SkipSelf(), ViewportRuler], ScrollDispatcher],\n  useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n"]}