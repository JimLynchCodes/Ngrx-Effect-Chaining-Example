{"version":3,"file":"effects.js","sourceRoot":"","sources":["../../src/effects.ts"],"names":[],"mappings":"OAAO,EAAE,KAAK,EAAE,MAAM,uBAAuB;OACtC,EAAE,cAAc,EAAE,MAAM,8BAA8B;AAI7D,IAAM,YAAY,GAAG,eAAe,CAAC;AAOrC,uBAAuB,EAAiC;QAA/B,6DAAQ;IAC/B,MAAM,CAAC,UAAS,MAAW,EAAE,YAAoB;QAC/C,EAAE,CAAC,CAAC,CAAE,OAAe,CAAC,cAAc,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;YAC1D,OAAe,CAAC,cAAc,CAAC,YAAY,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;QAC5D,CAAC;QAED,IAAM,OAAO,GAAsB,OAAe,CAAC,cAAc,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;QACxF,IAAM,QAAQ,GAAmB,EAAE,0BAAY,EAAE,kBAAQ,EAAE,CAAC;QAE3D,OAAe,CAAC,cAAc,CAAC,YAAY,EAAO,OAAO,SAAE,QAAQ,EAAE,EAAE,MAAM,CAAC,CAAC;IAClF,CAAC,CAAC;AACJ,CAAC;AAED,mCAAmC,QAAa;IAC9C,IAAM,MAAM,GAAG,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;IAE/C,EAAE,CAAC,CAAC,CAAE,OAAe,CAAC,cAAc,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;QAC3D,MAAM,CAAC,EAAE,CAAC;IACZ,CAAC;IAED,MAAM,CAAE,OAAe,CAAC,cAAc,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;AAC/D,CAAC;AAED,6BAA6B,QAAa;IACxC,IAAM,WAAW,GAAsB,kBAAkB,CAAC,QAAQ,CAAC,CAAC,GAAG,CACrE,UAAC,EAA0B;YAAxB,8BAAY,EAAE,sBAAQ;QACvB,IAAM,UAAU,GAAG,OAAO,QAAQ,CAAC,YAAY,CAAC,KAAK,UAAU;YAC7D,QAAQ,CAAC,YAAY,CAAC,EAAE,GAAG,QAAQ,CAAC,YAAY,CAAC,CAAC;QAEpD,EAAE,CAAC,CAAC,QAAQ,KAAK,KAAK,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACzC,CAAC;QAED,MAAM,CAAC,UAAU,CAAC;IACpB,CAAC,CACF,CAAC;IAEF,MAAM,CAAC,KAAK,eAAI,WAAW,CAAC,CAAC;AAC/B,CAAC","sourcesContent":["import { merge } from 'rxjs/observable/merge';\nimport { ignoreElements } from 'rxjs/operator/ignoreElements';\nimport { Store } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\n\nconst METADATA_KEY = '@ngrx/effects';\n\nexport interface EffectMetadata {\n  propertyName: string;\n  dispatch: boolean;\n}\n\nexport function Effect({ dispatch } = { dispatch: true }): PropertyDecorator {\n  return function(target: any, propertyName: string) {\n    if (!(Reflect as any).hasOwnMetadata(METADATA_KEY, target)) {\n      (Reflect as any).defineMetadata(METADATA_KEY, [], target);\n    }\n\n    const effects: EffectMetadata[] = (Reflect as any).getOwnMetadata(METADATA_KEY, target);\n    const metadata: EffectMetadata = { propertyName, dispatch };\n\n    (Reflect as any).defineMetadata(METADATA_KEY, [ ...effects, metadata ], target);\n  };\n}\n\nexport function getEffectsMetadata(instance: any): EffectMetadata[] {\n  const target = Object.getPrototypeOf(instance);\n\n  if (!(Reflect as any).hasOwnMetadata(METADATA_KEY, target)) {\n    return [];\n  }\n\n  return (Reflect as any).getOwnMetadata(METADATA_KEY, target);\n}\n\nexport function mergeEffects(instance: any): Observable<any> {\n  const observables: Observable<any>[] = getEffectsMetadata(instance).map(\n    ({ propertyName, dispatch }): Observable<any> => {\n      const observable = typeof instance[propertyName] === 'function' ?\n        instance[propertyName]() : instance[propertyName];\n\n      if (dispatch === false) {\n        return ignoreElements.call(observable);\n      }\n\n      return observable;\n    }\n  );\n\n  return merge(...observables);\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}